<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizzatore Modelli 3D - Versione Finale</title>
    
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas3d {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin: 0 0 10px 0;
            text-align: center;
        }
        
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .file-input {
            display: none;
        }
        
        .file-label {
            background: #3498db;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            border: none;
            display: inline-block;
        }
        
        .file-label:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
        }
        
        .btn-green {
            background: #27ae60;
            color: white;
        }
        
        .btn-green:hover {
            background: #229954;
            transform: translateY(-2px);
        }
        
        .btn-red {
            background: #e74c3c;
            color: white;
        }
        
        .btn-red:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }
        
        .btn-blue {
            background: #3498db;
            color: white;
        }
        
        .btn-blue:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        #status {
            background: rgba(236, 240, 241, 0.9);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            color: #2c3e50;
            font-family: monospace;
            min-width: 200px;
            text-align: center;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        #instructions h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        #instructions ul {
            margin: 0;
            padding-left: 20px;
        }
        
        #instructions li {
            margin: 5px 0;
        }
        
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 200;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #ecf0f1;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none !important;
        }
        
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.95);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 200;
            max-width: 400px;
        }
        
        /* HOME PAGE STYLES */
        #homePage {
            width: 100%;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #homeHeader {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        
        #homeHeader h1 {
            font-size: 48px;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        #homeHeader .logo {
            height: 60px;
            width: auto;
        }
        
        #homeHeader p {
            font-size: 20px;
            margin: 0 0 30px 0;
            opacity: 0.9;
        }
        
        #scenariosList {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 0 20px;
        }
        
        .scenario-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: row;
            min-height: 180px;
        }
        
        .scenario-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        }
        
        .scenario-card.placeholder {
            cursor: default;
        }
        
        .scenario-card.placeholder:hover {
            transform: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        
        .scenario-image {
            width: 200px;
            min-width: 200px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .scenario-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .placeholder-image {
            font-size: 60px;
            color: #dee2e6;
        }
        
        .scenario-info {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .scenario-info h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 24px;
            font-weight: bold;
        }
        
        .scenario-info p {
            margin: 0;
            color: #5a6c7d;
            font-size: 16px;
            line-height: 1.5;
        }
        
        /* SCENARIO PAGE STYLES */
        #scenarioPage {
            width: 100%;
            height: 100vh;
        }
        
        #navBar {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        #navBar #title {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
            margin: 0;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .scenario-card {
                flex-direction: column;
                min-height: auto;
            }
            
            .scenario-image {
                width: 100%;
                height: 150px;
            }
            
            #homeHeader h1 {
                font-size: 36px;
            }
            
            #scenariosList {
                grid-template-columns: 1fr;
                padding: 0 10px;
            }
        }
    </style>
    
    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
</head>
<body>
    <div id="container">
        <!-- HOME PAGE -->
        <div id="homePage">
            <div id="homeHeader">
                <h1>üéØ Visualizzatore Modelli 3D</h1>
                <p>Seleziona uno scenario per iniziare</p>
                
                <input type="file" id="homeConfigInput" accept=".txt,.cfg" class="file-input">
                <label for="homeConfigInput" class="file-label">
                    ‚öôÔ∏è Carica Configurazione Home
                </label>
            </div>
            
            <div id="scenariosList">
                <div class="scenario-card placeholder">
                    <div class="scenario-image">
                        <div class="placeholder-image">üìÅ</div>
                    </div>
                    <div class="scenario-info">
                        <h3>Carica Configurazione</h3>
                        <p>Seleziona un file di configurazione per vedere gli scenari disponibili</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- SCENARIO PAGE -->
        <div id="scenarioPage" class="hidden">
            <canvas id="canvas3d"></canvas>
            
            <div id="header">
                <div id="navBar">
                    <button class="btn-blue" onclick="goHome()">üè† Home</button>
                    <div id="title">üéØ Scenario: <span id="scenarioTitle">Nome Scenario</span></div>
                </div>
                
                <div id="controls">
                    <!-- Controlli Scenario -->
                    <button class="btn-blue" onclick="executeScenario()" id="scenarioBtn" disabled>üé¨ Esegui Scenario</button>
                    
                    <!-- Controlli Manuali -->
                    <input type="file" id="fileInput" accept=".obj,.stl,.gltf,.glb,.mtl,.jpg,.jpeg,.png,.bmp,.tga" class="file-input" multiple>
                    <label for="fileInput" class="file-label">
                        üìÅ Carica Modelli
                    </label>
                    
                    <input type="file" id="animationInput" accept=".txt,.csv" class="file-input">
                    <label for="animationInput" class="file-label">
                        üé¨ Carica Animazione
                    </label>
                    
                    <button class="btn-green" onclick="clearAll()">üóëÔ∏è Pulisci Tutto</button>
                    <button class="btn-red" onclick="resetView()">üîÑ Reset Vista</button>
                    <button class="btn-blue" onclick="startAnimation()" id="animationBtn" disabled>‚ñ∂Ô∏è Avvia Animazione</button>
                    
                    <div id="status">Scenario pronto</div>
                </div>
            </div>
        </div>
        
        <!-- <div id="instructions">
            <h3>üéÆ Controlli:</h3>
            <ul>
                <li><strong>Tasto sinistro + trascina:</strong> Sposta vista (Pan)</li>
                <li><strong>Tasto destro + trascina:</strong> Ruota modello</li>
                <li><strong>Rotella mouse:</strong> Zoom avanti/indietro</li>
            </ul>
            <h3>üé® Materiali & Texture:</h3>
            <ul>
                <li><strong>OBJ + MTL:</strong> Seleziona entrambi i file insieme</li>
                <li><strong>Con texture:</strong> Aggiungi file immagine (.jpg, .png)</li>
                <li><strong>Nomi identici:</strong> model.obj + model.mtl + texture.jpg</li>
                <li><strong>Solo OBJ:</strong> User√† colori casuali</li>
            </ul>
            <p style="font-size: 0.8em; color: #666; margin-top: 8px;">
                üí° <strong>Tip:</strong> Le texture devono essere nello stesso percorso del file MTL
            </p>
        </div> -->
        
        <div id="loader" class="hidden">
            <div class="spinner"></div>
            <p>Caricamento modello in corso...</p>
        </div>
        
        <div id="error" class="hidden">
            <p id="errorMessage">Errore</p>
            <button onclick="hideError()" style="background: rgba(255,255,255,0.2); color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                Chiudi
            </button>
        </div>
    </div>

    <script>
        // ===== VARIABILI GLOBALI =====
        let scene, camera, renderer;
        let loadedModels = []; // Array per contenere tutti i modelli caricati
        let isMouseDown = false, mouseButton = 0;
        let lastMouseX = 0, lastMouseY = 0;
        
        // Salvataggio vista
        let savedView = null;
        
        // Animazione
        let animationData = null;
        let animationInProgress = false;
        let animationStartTime = 0;
        
        // Scenari
        let scenariosConfig = null;
        let currentScenario = null;
        let scenarioAnimations = [];
        let currentAnimationIndex = 0;
        let scenarioInProgress = false;
        
        // Navigazione
        let currentPage = 'home'; // 'home' o 'scenario'
        let homeConfig = null;
        
        // Cache per texture caricate da file locali
        let textureCache = {};
        
        // ===== INIZIALIZZAZIONE =====
        function init() {
            updateStatus('Inizializzazione in corso...');
            
            try {
                // Verifica Three.js
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js non caricato');
                }
                
                // Canvas e dimensioni
                const canvas = document.getElementById('canvas3d');
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                updateStatus('Creazione scena 3D...');
                
                // Crea scena
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                
                // Crea camera
                camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.set(0, 0.3, 1);
                
                // Crea renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                updateStatus('Aggiunta illuminazione...');
                
                // Illuminazione ottimizzata per texture
                const ambientLight = new THREE.AmbientLight(0xf0f0f0, 10); // Aumentata ulteriormente per visibilit√† texture
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
                fillLight.position.set(-10, 0, -10);
                scene.add(fillLight);
                
                // Luce aggiuntiva frontale
                const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
                frontLight.position.set(0, 0, 10);
                scene.add(frontLight);
                
                // Luce dal basso per eliminare ombre troppo scure
                const bottomLight = new THREE.DirectionalLight(0xffffff, 0.4);
                bottomLight.position.set(0, -10, 0);
                scene.add(bottomLight);
                
                updateStatus('Configurazione controlli...');
                
                // Event listeners
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('wheel', onMouseWheel);
                canvas.addEventListener('contextmenu', e => e.preventDefault());
                window.addEventListener('resize', onWindowResize);
                document.getElementById('fileInput').addEventListener('change', onFileSelect);
                document.getElementById('animationInput').addEventListener('change', onAnimationFileSelect);
                document.getElementById('homeConfigInput').addEventListener('change', onHomeConfigSelect);
                
                updateStatus('Avvio rendering...');
                
                // Avvia rendering
                animate();
                
                updateStatus('‚úÖ Visualizzatore inizializzato - Caricamento configurazione Home...');
                
                // Carica automaticamente la configurazione Home
                loadDefaultHomeConfig();
                
                return true;
                
            } catch (error) {
                console.error('Errore inizializzazione:', error);
                updateStatus('‚ùå Errore: ' + error.message);
                showError('Errore durante l\'inizializzazione: ' + error.message);
                return false;
            }
        }
        
        // ===== LOOP DI RENDERING =====
        function animate() {
            requestAnimationFrame(animate);
            
            // Aggiorna animazione se in corso
            if (animationInProgress && animationData) {
                updateAnimation();
            }
            
            renderer.render(scene, camera);
        }
        
        
        // ===== AUTO-ZOOM PER TUTTI I MODELLI =====
        function autoFitAllModels() {
            if (loadedModels.length === 0) return;
            
            try {
                // Calcola il bounding box di tutti i modelli
                const overallBox = new THREE.Box3();
                
                loadedModels.forEach(model => {
                    const modelBox = new THREE.Box3().setFromObject(model);
                    overallBox.union(modelBox);
                });
                
                const center = overallBox.getCenter(new THREE.Vector3());
                const size = overallBox.getSize(new THREE.Vector3());
                
                // Calcola distanza ottimale per vedere tutti i modelli
                const maxDimension = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                const distance = Math.max(maxDimension / (2 * Math.tan(fov / 2)), 1);
                const finalDistance = Math.max(distance * 1.5, 0.5);
                
                // Posiziona camera per vedere tutti i modelli
                camera.position.set(center.x, center.y, center.z + finalDistance);
                camera.lookAt(center.x, center.y, center.z);
                
                console.log('Auto-zoom applicato per', loadedModels.length, 'modelli, distanza:', finalDistance);
            } catch (error) {
                console.warn('Errore auto-zoom:', error);
            }
        }
        
        // ===== SALVATAGGIO E RIPRISTINO VISTA =====
        function saveCurrentView() {
            savedView = {
                cameraPosition: camera.position.clone(),
                cameraRotation: camera.rotation.clone(),
                modelsRotations: loadedModels.map(model => ({
                    model: model,
                    rotation: model.rotation.clone(),
                    position: model.position.clone()
                }))
            };
            console.log('Vista salvata');
        }
        
        function restoreView() {
            if (!savedView) return;
            
            // Ripristina camera
            camera.position.copy(savedView.cameraPosition);
            camera.rotation.copy(savedView.cameraRotation);
            
            // Ripristina rotazioni e posizioni dei modelli esistenti
            savedView.modelsRotations.forEach(savedModel => {
                if (loadedModels.includes(savedModel.model)) {
                    savedModel.model.rotation.copy(savedModel.rotation);
                    savedModel.model.position.copy(savedModel.position);
                }
            });
            
            // Applica la stessa rotazione ai nuovi modelli
            if (savedView.modelsRotations.length > 0) {
                const referenceRotation = savedView.modelsRotations[0].rotation;
                const referencePosition = savedView.modelsRotations[0].position;
                
                loadedModels.forEach(model => {
                    // Se questo modello non era nella vista salvata, applica la rotazione di riferimento
                    const wasInSavedView = savedView.modelsRotations.some(saved => saved.model === model);
                    if (!wasInSavedView) {
                        model.rotation.copy(referenceRotation);
                        // Non copiamo la posizione perch√© i nuovi modelli devono rimanere centrati
                    }
                });
            }
            
            console.log('Vista ripristinata');
        }
        
        // ===== CARICAMENTO FILE =====
        function onFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Salva la vista attuale prima di caricare
            saveCurrentView();
            
            console.log('üîÑ File selezionati:', files.length);
            files.forEach(file => console.log('  üìÑ', file.name, '(' + file.size + ' bytes)'));
            
            // Reset dell'input file per permettere di ricaricare gli stessi file
            event.target.value = '';
            
            // Organizza i file per tipo
            const objFiles = files.filter(f => f.name.toLowerCase().endsWith('.obj'));
            const mtlFiles = files.filter(f => f.name.toLowerCase().endsWith('.mtl'));
            const stlFiles = files.filter(f => f.name.toLowerCase().endsWith('.stl'));
            const gltfFiles = files.filter(f => {
                const ext = f.name.toLowerCase().split('.').pop();
                return ['gltf', 'glb'].includes(ext);
            });
            const imageFiles = files.filter(f => {
                const ext = f.name.toLowerCase().split('.').pop();
                return ['jpg', 'jpeg', 'png', 'bmp', 'tga'].includes(ext);
            });
            const otherFiles = files.filter(f => {
                const ext = f.name.toLowerCase().split('.').pop();
                return !['obj', 'mtl', 'stl', 'gltf', 'glb', 'jpg', 'jpeg', 'png', 'bmp', 'tga'].includes(ext);
            });
            
            console.log('üìä Analisi file:');
            console.log('  üéØ OBJ:', objFiles.length);
            console.log('  üé® MTL:', mtlFiles.length);
            console.log('  üî∫ STL:', stlFiles.length);
            console.log('  üéÅ GLTF/GLB:', gltfFiles.length);
            console.log('  üñºÔ∏è Immagini:', imageFiles.length);
            console.log('  ‚ùì Altri:', otherFiles.length);
            
            // Prima carica tutte le immagini nella cache
            if (imageFiles.length > 0) {
                console.log('üñºÔ∏è Caricamento immagini nella cache texture...');
                loadImagesToCache(imageFiles, function() {
                    console.log('‚úÖ Tutte le immagini caricate nella cache');
                    proceedWithModelLoading();
                });
            } else {
                proceedWithModelLoading();
            }
            
            function proceedWithModelLoading() {
            
            // Gestisci file non supportati
            if (otherFiles.length > 0) {
                const unsupported = otherFiles.map(f => f.name).join(', ');
                showError(`File non supportati: ${unsupported}. Usa OBJ+MTL o STL.`);
                return;
            }
            
            // Carica in base al tipo
            if (gltfFiles.length > 0) {
                // Priorit√† a GLTF/GLB (formato pi√π moderno)
                loadGLTFFile(gltfFiles[0]);
            } else if (objFiles.length > 0) {
                // Se c'√® un OBJ, cerca il corrispondente MTL
                const objFile = objFiles[0]; // Prendi il primo OBJ
                const baseName = objFile.name.replace(/\.obj$/i, '');
                const correspondingMtl = mtlFiles.find(mtl => 
                    mtl.name.replace(/\.mtl$/i, '') === baseName
                );
                
                console.log('üéØ File OBJ principale:', objFile.name);
                if (correspondingMtl) {
                    console.log('üé® File MTL corrispondente trovato:', correspondingMtl.name);
                    loadOBJWithMTL(objFile, correspondingMtl);
                } else {
                    console.log('üé® Nessun MTL corrispondente, carico OBJ senza materiali');
                    if (mtlFiles.length > 0) {
                        console.log('üí° Suggerimento: rinomina', mtlFiles[0].name, 'in', baseName + '.mtl');
                    }
                    loadOBJFile(objFile);
                }
            } else if (stlFiles.length > 0) {
                loadSTLFile(stlFiles[0]);
            } else {
                showError('Seleziona almeno un file OBJ, STL, GLTF o GLB.');
            }
            }
        }
        
        // ===== CARICAMENTO IMMAGINI IN CACHE =====
        function loadImagesToCache(imageFiles, callback) {
            let loadedCount = 0;
            
            if (imageFiles.length === 0) {
                callback();
                return;
            }
            
            imageFiles.forEach(imageFile => {
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const dataURL = event.target.result;
                    
                    // Crea texture da data URL
                    const loader = new THREE.TextureLoader();
                    loader.load(dataURL, function(texture) {
                        // Configura texture per mappatura corretta
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        texture.flipY = false;
                        
                        // Migliora i colori della texture
                        texture.encoding = THREE.sRGBEncoding;
                        texture.generateMipmaps = true;
                        texture.minFilter = THREE.LinearMipmapLinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        
                        // Salva nella cache con nome file e varianti
                        const fileName = imageFile.name;
                        const baseName = fileName.split('.')[0];
                        
                        textureCache[fileName] = texture;
                        textureCache[fileName.toLowerCase()] = texture;
                        textureCache[baseName] = texture;
                        textureCache[baseName.toLowerCase()] = texture;
                        
                        console.log(`‚úÖ Texture caricata nella cache: ${fileName}`);
                        console.log('üñºÔ∏è Dimensioni texture:', texture.image.width, 'x', texture.image.height);
                        
                        loadedCount++;
                        if (loadedCount >= imageFiles.length) {
                            callback();
                        }
                    }, undefined, function(error) {
                        console.error(`‚ùå Errore caricamento texture: ${imageFile.name}`, error);
                        loadedCount++;
                        if (loadedCount >= imageFiles.length) {
                            callback();
                        }
                    });
                };
                
                reader.onerror = function() {
                    console.error(`‚ùå Errore lettura file immagine: ${imageFile.name}`);
                    loadedCount++;
                    if (loadedCount >= imageFiles.length) {
                        callback();
                    }
                };
                
                reader.readAsDataURL(imageFile);
            });
        }
        
        // ===== CARICAMENTO OBJ CON MTL =====
        function loadOBJWithMTL(objFile, mtlFile) {
            console.log('üé® Inizio caricamento OBJ+MTL:', objFile.name, '+', mtlFile.name);
            updateStatus(`Caricamento ${objFile.name} con materiali...`);
            showLoader();
            
            // I modelli precedenti rimangono nella scena per caricamento multiplo
            
            // Prima carica il file MTL
            const mtlReader = new FileReader();
            mtlReader.onload = function(event) {
                try {
                    console.log('üìö Parsing file MTL...');
                    const mtlText = event.target.result;
                    const materials = parseMTL(mtlText, mtlFile.name);
                    
                    console.log('‚úÖ Materiali MTL parsati:', Object.keys(materials));
                    
                    // Carica le texture per tutti i materiali
                    loadTexturesForMaterials(materials, function(materialsWithTextures) {
                        console.log('üñºÔ∏è Texture caricate per i materiali');
                        
                        // Poi carica il file OBJ
                        const objReader = new FileReader();
                        objReader.onload = function(event) {
                            try {
                                console.log('üìÑ Parsing file OBJ con materiali e texture...');
                                const objText = event.target.result;
                                const model = parseOBJWithMaterials(objText, objFile.name, materialsWithTextures);
                                
                                if (!model) {
                                    throw new Error('Parser OBJ+MTL ha restituito null');
                                }
                                
                                // Aggiungi il modello all'array e alla scena
                                loadedModels.push(model);
                                scene.add(model);
                                
                                // Reset e poi ripristina vista
                                resetViewInternal();
                                restoreView();
                                hideLoader();
                                updateStatus(`‚úÖ ${objFile.name} caricato! Totale modelli: ${loadedModels.length}`);
                                
                            } catch (error) {
                                console.error('‚ùå Errore caricamento OBJ:', error);
                                showError('Errore nel caricamento del file OBJ: ' + error.message);
                                hideLoader();
                            }
                        };
                        
                        objReader.readAsText(objFile);
                    });
                    
                } catch (error) {
                    console.error('‚ùå Errore caricamento MTL:', error);
                    showError('Errore nel caricamento del file MTL: ' + error.message);
                    hideLoader();
                }
            };
            
            mtlReader.readAsText(mtlFile);
        }
        
        // ===== PULIZIA MATERIALI =====
        function disposeMaterial(material) {
            if (!material) return;
            
            // Pulisci le texture
            if (material.map) material.map.dispose();
            if (material.normalMap) material.normalMap.dispose();
            if (material.bumpMap) material.bumpMap.dispose();
            if (material.specularMap) material.specularMap.dispose();
            if (material.envMap) material.envMap.dispose();
            
            // Pulisci il materiale
            material.dispose();
        }
        
        // ===== CARICAMENTO TEXTURE =====
        function loadTexturesForMaterials(materials, callback) {
            const materialNames = Object.keys(materials);
            let processedCount = 0;
            
            console.log('üñºÔ∏è Inizio caricamento texture per', materialNames.length, 'materiali');
            
            function checkComplete() {
                processedCount++;
                if (processedCount >= materialNames.length) {
                    console.log('‚úÖ Caricamento texture completato');
                    callback(materials);
                }
            }
            
            if (materialNames.length === 0) {
                callback(materials);
                return;
            }
            
            materialNames.forEach(materialName => {
                const material = materials[materialName];
                let textureCount = 0;
                let loadedCount = 0;
                
                // Conta quante texture dobbiamo caricare per questo materiale
                if (material.map) textureCount++;
                if (material.normalMap) textureCount++;
                if (material.bumpMap) textureCount++;
                if (material.specularMap) textureCount++;
                
                if (textureCount === 0) {
                    console.log(`üìù Nessuna texture per materiale: ${materialName}`);
                    checkComplete();
                    return;
                }
                
                console.log(`üñºÔ∏è Caricamento ${textureCount} texture per materiale: ${materialName}`);
                updateStatus(`Caricamento texture per ${materialName}...`);
                
                function textureLoaded() {
                    loadedCount++;
                    if (loadedCount >= textureCount) {
                        console.log(`‚úÖ Texture caricate per materiale: ${materialName}`);
                        checkComplete();
                    }
                }
                
                function textureError(texturePath) {
                    console.warn(`‚ö†Ô∏è Errore caricamento texture: ${texturePath} per materiale: ${materialName}`);
                    textureLoaded(); // Continua comunque
                }
                
                // Carica texture diffusa (map_Kd)
                if (material.map) {
                    loadSingleTexture(material.map, function(texture) {
                        material.loadedMap = texture;
                        console.log(`  ‚úÖ Texture diffusa caricata: ${material.map}`);
                        textureLoaded();
                    }, function() {
                        textureError(material.map);
                    });
                }
                
                // Carica normal map
                if (material.normalMap) {
                    loadSingleTexture(material.normalMap, function(texture) {
                        material.loadedNormalMap = texture;
                        console.log(`  ‚úÖ Normal map caricata: ${material.normalMap}`);
                        textureLoaded();
                    }, function() {
                        textureError(material.normalMap);
                    });
                }
                
                // Carica bump map
                if (material.bumpMap) {
                    loadSingleTexture(material.bumpMap, function(texture) {
                        material.loadedBumpMap = texture;
                        console.log(`  ‚úÖ Bump map caricata: ${material.bumpMap}`);
                        textureLoaded();
                    }, function() {
                        textureError(material.bumpMap);
                    });
                }
                
                // Carica specular map
                if (material.specularMap) {
                    loadSingleTexture(material.specularMap, function(texture) {
                        material.loadedSpecularMap = texture;
                        console.log(`  ‚úÖ Specular map caricata: ${material.specularMap}`);
                        textureLoaded();
                    }, function() {
                        textureError(material.specularMap);
                    });
                }
            });
        }
        
        // ===== CARICAMENTO SINGOLA TEXTURE =====
        function loadSingleTexture(texturePath, onLoad, onError) {
            console.log(`üñºÔ∏è Tentativo caricamento texture: ${texturePath}`);
            
            // Prima prova a cercare nella cache
            const cacheKeys = [
                texturePath,
                texturePath.toLowerCase(),
                texturePath.split('\\').pop(), // Solo il nome del file (Windows)
                texturePath.split('/').pop(),  // Solo il nome del file (Unix)
                texturePath.split('\\').pop().split('.')[0], // Nome senza estensione (Windows)
                texturePath.split('/').pop().split('.')[0]   // Nome senza estensione (Unix)
            ];
            
            for (let key of cacheKeys) {
                if (textureCache[key]) {
                    console.log(`‚úÖ Texture trovata nella cache: ${key} -> ${texturePath}`);
                    // Clona la texture per evitare problemi di condivisione
                    const cachedTexture = textureCache[key];
                    const clonedTexture = cachedTexture.clone();
                    clonedTexture.needsUpdate = true;
                    onLoad(clonedTexture);
                    return;
                }
            }
            
            console.log('üîç Texture non trovata nella cache, provo caricamento da URL...');
            
            const loader = new THREE.TextureLoader();
            
            // Prova a caricare come URL relativo
            loader.load(
                texturePath,
                function(texture) {
                    // Texture caricata con successo - configura per mappatura corretta
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.flipY = true; // Correggi orientamento texture
                    texture.encoding = THREE.sRGBEncoding;
                    texture.generateMipmaps = true;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    console.log(`‚úÖ Texture caricata da URL: ${texturePath}`);
                    onLoad(texture);
                },
                function(progress) {
                    // Progresso caricamento
                },
                function(error) {
                    // Errore caricamento - prova con percorso alternativo
                    console.warn('‚ö†Ô∏è Texture non trovata come URL:', texturePath, '- Provo percorsi alternativi');
                    
                    // Lista di percorsi alternativi da provare
                    const alternatePaths = [
                        `./${texturePath}`,
                        `./textures/${texturePath}`,
                        `./images/${texturePath}`,
                        texturePath.replace(/\\/g, '/'), // Converte backslash in forward slash
                        texturePath.split('\\').pop(), // Solo il nome del file
                        texturePath.split('/').pop()   // Solo il nome del file
                    ];
                    
                    tryAlternatePaths(alternatePaths, 0);
                    
                    function tryAlternatePaths(paths, index) {
                        if (index >= paths.length) {
                            console.error('‚ùå Texture non trovata in nessun percorso:', texturePath);
                            console.log('üí° Texture disponibili nella cache:', Object.keys(textureCache));
                            onError();
                            return;
                        }
                        
                        const altPath = paths[index];
                        loader.load(
                            altPath,
                            function(texture) {
                                console.log(`‚úÖ Texture trovata in percorso alternativo: ${altPath}`);
                                texture.wrapS = THREE.ClampToEdgeWrapping;
                                texture.wrapT = THREE.ClampToEdgeWrapping;
                                texture.flipY = false;
                                texture.encoding = THREE.sRGBEncoding;
                                texture.generateMipmaps = true;
                                texture.minFilter = THREE.LinearMipmapLinearFilter;
                                texture.magFilter = THREE.LinearFilter;
                                onLoad(texture);
                            },
                            undefined,
                            function() {
                                tryAlternatePaths(paths, index + 1);
                            }
                        );
                    }
                }
            );
        }
        
        // ===== PARSER MTL =====
        function parseMTL(text, fileName) {
            console.log('üé® Inizio parsing MTL:', fileName);
            
            const materials = {};
            let currentMaterial = null;
            const lines = text.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === '' || line.startsWith('#')) {
                    continue;
                }
                
                const parts = line.split(/\s+/);
                const command = parts[0].toLowerCase();
                
                if (command === 'newmtl') {
                    // Nuovo materiale
                    const materialName = parts[1];
                    currentMaterial = {
                        name: materialName,
                        ambient: [0.2, 0.2, 0.2],     // Ka
                        diffuse: [0.8, 0.8, 0.8],     // Kd
                        specular: [1.0, 1.0, 1.0],    // Ks
                        shininess: 10.0,              // Ns
                        opacity: 1.0,                 // d
                        illum: 2                      // illum
                    };
                    materials[materialName] = currentMaterial;
                    console.log('üÜï Nuovo materiale:', materialName);
                    
                } else if (currentMaterial) {
                    switch (command) {
                        case 'ka': // Colore ambientale
                            currentMaterial.ambient = [
                                parseFloat(parts[1]) || 0,
                                parseFloat(parts[2]) || 0,
                                parseFloat(parts[3]) || 0
                            ];
                            break;
                            
                        case 'kd': // Colore diffuso
                            currentMaterial.diffuse = [
                                parseFloat(parts[1]) || 0,
                                parseFloat(parts[2]) || 0,
                                parseFloat(parts[3]) || 0
                            ];
                            break;
                            
                        case 'ks': // Colore speculare
                            currentMaterial.specular = [
                                parseFloat(parts[1]) || 0,
                                parseFloat(parts[2]) || 0,
                                parseFloat(parts[3]) || 0
                            ];
                            break;
                            
                        case 'ns': // Shininess
                            currentMaterial.shininess = parseFloat(parts[1]) || 10.0;
                            break;
                            
                        case 'd': // Opacit√†
                            currentMaterial.opacity = parseFloat(parts[1]) || 1.0;
                            break;
                            
                        case 'tr': // Trasparenza (1 - opacit√†)
                            currentMaterial.opacity = 1.0 - (parseFloat(parts[1]) || 0);
                            break;
                            
                        case 'illum': // Modello di illuminazione
                            currentMaterial.illum = parseInt(parts[1]) || 2;
                            break;
                            
                        case 'map_kd': // Texture map diffusa
                            currentMaterial.map = parts[1];
                            console.log('üñºÔ∏è Texture map diffusa trovata:', parts[1]);
                            break;
                            
                        case 'map_ks': // Texture map speculare
                            currentMaterial.specularMap = parts[1];
                            console.log('üñºÔ∏è Texture map speculare trovata:', parts[1]);
                            break;
                            
                        case 'map_bump':
                        case 'bump': // Bump map
                            currentMaterial.bumpMap = parts[1];
                            console.log('üñºÔ∏è Bump map trovata:', parts[1]);
                            break;
                            
                        case 'map_norm': // Normal map
                            currentMaterial.normalMap = parts[1];
                            console.log('üñºÔ∏è Normal map trovata:', parts[1]);
                            break;
                    }
                }
            }
            
            console.log('üìä MTL parsing completato:');
            console.log('  ‚Ä¢ Materiali trovati:', Object.keys(materials).length);
            Object.keys(materials).forEach(name => {
                const mat = materials[name];
                console.log(`    üé® ${name}:`);
                console.log(`        ‚Ä¢ Diffuse: RGB(${mat.diffuse.join(', ')})`);
                console.log(`        ‚Ä¢ Ambient: RGB(${mat.ambient.join(', ')})`);
                console.log(`        ‚Ä¢ Specular: RGB(${mat.specular.join(', ')})`);
                console.log(`        ‚Ä¢ Opacity: ${mat.opacity}, Shininess: ${mat.shininess}`);
                if (mat.map) console.log(`        ‚Ä¢ Texture: ${mat.map}`);
            });
            
            return materials;
        }
        
        // ===== PARSER OBJ CON MATERIALI =====
        function parseOBJWithMaterials(text, fileName, materials) {
            console.log('üîç Inizio parsing OBJ con materiali:', fileName);
            
            const vertices = [];
            const uvs = []; // Coordinate UV
            const faces = [];
            const groups = {}; // Raggruppa facce per materiale
            let currentMaterial = 'default';
            let vertexCount = 0;
            let uvCount = 0;
            
            // Inizializza gruppo default
            groups[currentMaterial] = {
                faces: [],
                uvs: []
            };
            
            const lines = text.split('\n');
            console.log('üìÑ Numero di righe da processare:', lines.length);
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === '' || line.startsWith('#')) {
                    continue;
                }
                
                if (line.startsWith('v ')) {
                    // Vertex: v x y z [r g b] (i colori vertici sono opzionali da Blender 4.4)
                    const parts = line.split(/\s+/);
                    if (parts.length >= 4) {
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);
                        const z = parseFloat(parts[3]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            vertices.push(x, y, z);
                            vertexCount++;
                            
                            // Log debug per colori vertici se presenti
                            if (parts.length > 6 && vertexCount <= 5) {
                                console.log(`üé® Vertice ${vertexCount} con colori: RGB(${parts[4]}, ${parts[5]}, ${parts[6]})`);
                            }
                        }
                    }
                } else if (line.startsWith('vt ')) {
                    // Coordinate UV texture
                    const parts = line.split(/\s+/);
                    if (parts.length >= 3) {
                        const u = parseFloat(parts[1]);
                        const v = parseFloat(parts[2]);
                        
                        if (!isNaN(u) && !isNaN(v)) {
                            uvs.push(u, v);
                            uvCount++;
                            
                            if (uvCount <= 5) {
                                console.log(`üó∫Ô∏è UV ${uvCount}: (${u}, ${v})`);
                            }
                        }
                    }
                } else if (line.startsWith('usemtl ')) {
                    // Cambia materiale corrente
                    currentMaterial = line.substring(7).trim();
                    console.log('üé® Cambiato materiale a:', currentMaterial);
                    
                    if (!groups[currentMaterial]) {
                        groups[currentMaterial] = {
                            faces: [],
                            uvs: []
                        };
                    }
                } else if (line.startsWith('f ')) {
                    // Face: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
                    const parts = line.split(/\s+/);
                    const faceVertices = [];
                    const faceUVs = [];
                    
                    for (let j = 1; j < parts.length; j++) {
                        const vertexRef = parts[j].trim();
                        if (vertexRef === '') continue;
                        
                        const refs = vertexRef.split('/');
                        const vertexIndex = parseInt(refs[0]) - 1;
                        const uvIndex = refs.length > 1 && refs[1] ? parseInt(refs[1]) - 1 : -1;
                        
                        if (vertexIndex >= 0 && vertexIndex < vertexCount) {
                            faceVertices.push(vertexIndex);
                            faceUVs.push(uvIndex);
                        }
                    }
                    
                    // Assicurati che il gruppo esista
                    if (!groups[currentMaterial]) {
                        groups[currentMaterial] = {
                            faces: [],
                            uvs: []
                        };
                    }
                    
                    // Triangola le facce e assegnale al materiale corrente
                    if (faceVertices.length >= 3) {
                        // Primo triangolo
                        groups[currentMaterial].faces.push(faceVertices[0], faceVertices[1], faceVertices[2]);
                        groups[currentMaterial].uvs.push(faceUVs[0], faceUVs[1], faceUVs[2]);
                        
                        // Secondo triangolo per quad
                        if (faceVertices.length === 4) {
                            groups[currentMaterial].faces.push(faceVertices[0], faceVertices[2], faceVertices[3]);
                            groups[currentMaterial].uvs.push(faceUVs[0], faceUVs[2], faceUVs[3]);
                        }
                    }
                }
            }
            
            console.log('üìä Parsing OBJ completato:');
            console.log('  ‚Ä¢ Vertici:', vertexCount);
            console.log('  ‚Ä¢ Coordinate UV:', uvCount);
            console.log('  ‚Ä¢ Gruppi materiali:', Object.keys(groups).length);
            
            if (vertices.length === 0) {
                throw new Error('Nessun vertice trovato');
            }
            
            // Crea il modello finale
            const modelGroup = new THREE.Group();
            modelGroup.name = fileName;
            
            // Crea un mesh per ogni materiale
            Object.keys(groups).forEach(materialName => {
                const group = groups[materialName];
                const faceIndices = group.faces || group; // Compatibilit√† con vecchio formato
                const uvIndices = group.uvs || [];
                
                if (faceIndices.length === 0) return;
                
                console.log(`üîß Creazione mesh per materiale "${materialName}":`, faceIndices.length / 3, 'triangoli');
                console.log(`üîç Debug materiale "${materialName}":`, materials[materialName] ? 'TROVATO' : 'NON TROVATO');
                if (materials[materialName]) {
                    console.log(`    ‚Ä¢ Materiale dati:`, materials[materialName]);
                }
                
                // Crea geometria per questo materiale
                const geometry = new THREE.BufferGeometry();
                
                // Per le texture, dobbiamo espandere i vertici perch√© ogni faccia pu√≤ avere UV diverse
                if (uvIndices.length > 0 && uvs.length > 0) {
                    const expandedVertices = [];
                    const expandedUVs = [];
                    const expandedIndices = [];
                    
                    // Espandi i vertici per ogni faccia con le loro UV
                    for (let i = 0; i < faceIndices.length; i++) {
                        const vertexIndex = faceIndices[i];
                        const uvIndex = uvIndices[i];
                        
                        // Aggiungi il vertice
                        expandedVertices.push(
                            vertices[vertexIndex * 3],
                            vertices[vertexIndex * 3 + 1],
                            vertices[vertexIndex * 3 + 2]
                        );
                        
                        // Aggiungi le coordinate UV originali
                        if (uvIndex >= 0 && uvIndex < uvCount) {
                            const u = uvs[uvIndex * 2];
                            const v = uvs[uvIndex * 2 + 1];
                            expandedUVs.push(u, v);
                            
                            // Debug: log primi 5 UV
                            if (i < 15) {
                                console.log(`üó∫Ô∏è Faccia ${Math.floor(i/3)} vertice ${i%3}: UV(${u.toFixed(3)}, ${v.toFixed(3)}) dal vertice ${vertexIndex}`);
                            }
                        } else {
                            expandedUVs.push(0, 0);
                        }
                        
                        // Nuovo indice sequenziale
                        expandedIndices.push(i);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(expandedVertices, 3));
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(expandedUVs, 2));
                    // Non servono pi√π indici perch√© ogni vertice √® unico
                    
                    console.log(`üó∫Ô∏è Geometria espansa per "${materialName}": ${expandedVertices.length / 3} vertici, ${expandedUVs.length / 2} UV`);
                } else {
                    // Senza UV, usa la geometria normale
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setIndex(faceIndices);
                }
                
                // Calcola le normali per l'illuminazione corretta
                geometry.computeVertexNormals();
                
                // Forza il ricalcolo delle normali
                geometry.normalizeNormals();
                
                // Crea il materiale THREE.js
                let threeMaterial;
                const mtlMaterial = materials[materialName];
                
                if (mtlMaterial) {
                    // Converti il materiale MTL in THREE.js
                    const diffuse = mtlMaterial.diffuse;
                    const specular = mtlMaterial.specular;
                    
                    const materialOptions = {
                        color: mtlMaterial.loadedMap ? new THREE.Color(1.0, 1.0, 1.0) : new THREE.Color(diffuse[0], diffuse[1], diffuse[2]),
                        specular: new THREE.Color(0.1, 0.1, 0.1), // Ridotto drasticamente il riflesso
                        shininess: Math.min(mtlMaterial.shininess * 0.1, 30), // Ridotta la lucentezza
                        transparent: mtlMaterial.opacity < 1.0,
                        opacity: mtlMaterial.opacity,
                        side: THREE.DoubleSide
                    };
                    
                    // Aggiungi emissive solo se non ci sono texture per migliorare la visibilit√†
                    if (!mtlMaterial.loadedMap) {
                        materialOptions.emissive = new THREE.Color(diffuse[0] * 0.1, diffuse[1] * 0.1, diffuse[2] * 0.1);
                    }
                    
                    // Applica texture se caricate
                    if (mtlMaterial.loadedMap) {
                        materialOptions.map = mtlMaterial.loadedMap;
                        console.log(`  üñºÔ∏è Texture diffusa applicata al materiale "${materialName}"`);
                    }
                    
                    if (mtlMaterial.loadedNormalMap) {
                        materialOptions.normalMap = mtlMaterial.loadedNormalMap;
                        console.log(`  üñºÔ∏è Normal map applicata al materiale "${materialName}"`);
                    }
                    
                    if (mtlMaterial.loadedBumpMap) {
                        materialOptions.bumpMap = mtlMaterial.loadedBumpMap;
                        materialOptions.bumpScale = 0.1; // Scala del bump
                        console.log(`  üñºÔ∏è Bump map applicata al materiale "${materialName}"`);
                    }
                    
                    if (mtlMaterial.loadedSpecularMap) {
                        materialOptions.specularMap = mtlMaterial.loadedSpecularMap;
                        console.log(`  üñºÔ∏è Specular map applicata al materiale "${materialName}"`);
                    }
                    
                    // Usa MeshLambertMaterial per texture senza riflessi
                    if (mtlMaterial.loadedMap) {
                        threeMaterial = new THREE.MeshLambertMaterial({
                            map: materialOptions.map,
                            transparent: materialOptions.transparent,
                            opacity: materialOptions.opacity,
                            side: materialOptions.side,
                            emissive: new THREE.Color(0x101010) // Leggero emissive per schiarire
                        });
                    } else {
                        threeMaterial = new THREE.MeshPhongMaterial(materialOptions);
                    }
                    
                    const textureInfo = [];
                    if (mtlMaterial.loadedMap) textureInfo.push('diffuse');
                    if (mtlMaterial.loadedNormalMap) textureInfo.push('normal');
                    if (mtlMaterial.loadedBumpMap) textureInfo.push('bump');
                    if (mtlMaterial.loadedSpecularMap) textureInfo.push('specular');
                    
                    console.log(`  üé® Materiale MTL applicato: RGB(${diffuse.join(', ')})${textureInfo.length > 0 ? ', texture: [' + textureInfo.join(', ') + ']' : ''}`);
                    console.log(`      ‚Ä¢ Colore finale: #${materialOptions.color.getHexString()}`);
                    console.log(`      ‚Ä¢ Opacit√†: ${materialOptions.opacity}${materialOptions.emissive ? ', Emissive: #' + materialOptions.emissive.getHexString() : ', Emissive: nessuno'}`);
                } else {
                    // Materiale di fallback - usa colori pi√π vivaci
                    const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xa55eea, 0xe17055, 0x00b894];
                    const colorIndex = Object.keys(groups).indexOf(materialName) % colors.length;
                    const randomColor = colors[colorIndex];
                    
                    threeMaterial = new THREE.MeshPhongMaterial({
                        color: randomColor,
                        side: THREE.DoubleSide,
                        shininess: 30,
                        // Aggiungi un po' di emissive per renderlo pi√π visibile
                        emissive: new THREE.Color(randomColor).multiplyScalar(0.1)
                    });
                    
                    console.log(`  üé® Materiale fallback per "${materialName}": #${randomColor.toString(16)} (index: ${colorIndex})`);
                    console.log(`      ‚ö†Ô∏è  ATTENZIONE: Materiale MTL "${materialName}" non trovato, usando fallback`);
                }
                
                // Crea mesh
                const mesh = new THREE.Mesh(geometry, threeMaterial);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = `${fileName}_${materialName}`;
                
                modelGroup.add(mesh);
            });
            
            console.log('‚úÖ Modello con materiali creato:', modelGroup.children.length, 'mesh');
            
            return modelGroup;
        }
        
        // ===== CARICAMENTO OBJ SEMPLICE =====
        function loadOBJFile(file) {
            console.log('üì¶ Inizio caricamento file OBJ:', file.name);
            updateStatus('Lettura file OBJ...');
            
            // I modelli precedenti rimangono nella scena per caricamento multiplo
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                console.log('üìÑ File OBJ letto, inizio parsing...');
                updateStatus('Parsing file OBJ...');
                
                try {
                    const objText = event.target.result;
                    
                    if (!objText || objText.trim() === '') {
                        throw new Error('File OBJ vuoto o corrotto');
                    }
                    
                    console.log('üìù Contenuto file OBJ:', objText.substring(0, 200) + '...');
                    
                    const model = parseOBJ(objText, file.name);
                    
                    if (!model) {
                        throw new Error('Parser OBJ ha restituito null');
                    }
                    
                    console.log('‚úÖ Modello OBJ parsato con successo');
                    updateStatus('Aggiunta modello alla scena...');
                    
                    // Aggiungi il modello all'array e alla scena
                    loadedModels.push(model);
                    scene.add(model);
                    
                    console.log('üìä Modello aggiunto alla scena, oggetti totali:', scene.children.length);
                    
                    // Reset e poi ripristina vista
                    resetViewInternal();
                    restoreView();
                    hideLoader();
                    updateStatus(`‚úÖ ${file.name} caricato! Totale modelli: ${loadedModels.length}`);
                    
                } catch (error) {
                    console.error('‚ùå Errore dettagliato caricamento OBJ:', error);
                    showError('Errore nel caricamento del file OBJ: ' + error.message);
                    hideLoader();
                    updateStatus('‚ùå Errore caricamento OBJ');
                }
            };
            
            reader.onerror = function(error) {
                console.error('‚ùå Errore lettura file:', error);
                showError('Errore nella lettura del file OBJ');
                hideLoader();
                updateStatus('‚ùå Errore lettura file');
            };
            
            reader.onprogress = function(event) {
                if (event.lengthComputable) {
                    const percent = Math.round((event.loaded / event.total) * 100);
                    updateStatus(`Lettura file: ${percent}%`);
                }
            };
            
            console.log('üìñ Inizio lettura file come testo...');
            reader.readAsText(file);
        }
        
        // ===== PARSER OBJ MIGLIORATO =====
        function parseOBJ(text, fileName) {
            console.log('üîç Inizio parsing OBJ per file:', fileName);
            
            // Pulisci e prepara i dati
            const vertices = [];
            const faces = [];
            const lines = text.split('\n');
            let vertexCount = 0;
            let faceCount = 0;
            
            console.log('üìÑ Numero di righe da processare:', lines.length);
            
            // Prima passata: conta elementi per debug
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === '' || line.startsWith('#')) {
                    continue; // Salta righe vuote e commenti
                }
                
                if (line.startsWith('v ')) {
                    // Vertex: v x y z [r g b] (i colori vertici sono opzionali)
                    const parts = line.split(/\s+/); // Usa regex per gestire spazi multipli
                    
                    if (parts.length >= 4) {
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);
                        const z = parseFloat(parts[3]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            vertices.push(x, y, z);
                            vertexCount++;
                            
                            // Log se ci sono colori vertici (parts[4], parts[5], parts[6])
                            if (parts.length > 6) {
                                console.log(`üé® Vertice ${vertexCount} con colori: RGB(${parts[4]}, ${parts[5]}, ${parts[6]})`);
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Vertice invalido alla riga', i + 1, ':', line);
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Formato vertice invalido alla riga', i + 1, ':', line);
                    }
                } else if (line.startsWith('f ')) {
                    // Face: f v1 v2 v3 (pu√≤ avere texture/normal coords che ignoriamo)
                    const parts = line.split(/\s+/);
                    const faceVertices = [];
                    
                    for (let j = 1; j < parts.length; j++) {
                        const vertexRef = parts[j].trim();
                        if (vertexRef === '') continue;
                        
                        // Estrai solo l'indice del vertice (ignora texture/normal)
                        const vertexIndex = parseInt(vertexRef.split('/')[0]) - 1; // OBJ usa 1-based indexing
                        
                        if (vertexIndex >= 0 && vertexIndex < vertexCount) {
                            faceVertices.push(vertexIndex);
                        } else {
                            console.warn('‚ö†Ô∏è Indice vertice invalido:', vertexIndex, 'alla riga', i + 1);
                        }
                    }
                    
                    // Triangola le facce
                    if (faceVertices.length >= 3) {
                        // Triangolo base
                        faces.push(faceVertices[0], faceVertices[1], faceVertices[2]);
                        faceCount++;
                        
                        // Se √® un quad, aggiungi secondo triangolo
                        if (faceVertices.length === 4) {
                            faces.push(faceVertices[0], faceVertices[2], faceVertices[3]);
                            faceCount++;
                        }
                        
                        // Per poligoni con pi√π di 4 lati (fan triangulation)
                        for (let k = 4; k < faceVertices.length; k++) {
                            faces.push(faceVertices[0], faceVertices[k-1], faceVertices[k]);
                            faceCount++;
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Faccia con meno di 3 vertici alla riga', i + 1, ':', line);
                    }
                }
            }
            
            console.log('üìä Parsing completato:');
            console.log('  ‚Ä¢ Vertici trovati:', vertexCount);
            console.log('  ‚Ä¢ Facce create:', faceCount);
            console.log('  ‚Ä¢ Array vertices lunghezza:', vertices.length);
            console.log('  ‚Ä¢ Array faces lunghezza:', faces.length);
            
            if (vertices.length === 0) {
                throw new Error(`Nessun vertice trovato nel file OBJ ${fileName}`);
            }
            
            if (faces.length === 0) {
                console.warn('‚ö†Ô∏è Nessuna faccia trovata, creo geometria solo con vertici');
            }
            
            // Crea geometria THREE.js
            console.log('üîß Creazione geometria THREE.js...');
            const geometry = new THREE.BufferGeometry();
            
            // Aggiungi vertici
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            // Aggiungi indici se ci sono facce
            if (faces.length > 0) {
                geometry.setIndex(faces);
            }
            
            // Calcola normali per l'illuminazione
            geometry.computeVertexNormals();
            
            // Calcola bounding sphere per l'auto-zoom
            geometry.computeBoundingSphere();
            
            console.log('‚úÖ Geometria creata, bounding sphere:', geometry.boundingSphere);
            
            // Crea materiale con colore casuale per distinguere modelli diversi
            const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xa55eea];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const material = new THREE.MeshLambertMaterial({ 
                color: randomColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            console.log('üé® Materiale creato con colore:', '#' + randomColor.toString(16));
            
            // Crea mesh finale
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Aggiungi nome per debug
            mesh.name = fileName;
            
            console.log('‚úÖ Mesh finale creata per:', fileName);
            
            return mesh;
        }
        
        // ===== CARICAMENTO GLTF/GLB =====
        function loadGLTFFile(file) {
            console.log('üéÅ Inizio caricamento file GLTF/GLB:', file.name);
            updateStatus(`Caricamento ${file.name}...`);
            showLoader();
            
            // Carica dinamicamente GLTFLoader se non disponibile
            if (typeof THREE.GLTFLoader === 'undefined') {
                console.log('üì¶ Caricamento GLTFLoader...');
                updateStatus('Caricamento GLTFLoader...');
                
                // Prova diversi CDN per GLTFLoader
                const urls = [
                    'https://unpkg.com/three@0.155.0/examples/js/loaders/GLTFLoader.js',
                    'https://threejs.org/examples/js/loaders/GLTFLoader.js',
                    'https://cdn.skypack.dev/three@0.155.0/examples/jsm/loaders/GLTFLoader.js'
                ];
                
                let urlIndex = 0;
                
                function tryLoadGLTFLoader() {
                    if (urlIndex >= urls.length) {
                        console.error('‚ùå Tutti i CDN falliti');
                        showError('GLTFLoader non disponibile. Usa file OBJ+MTL invece.');
                        hideLoader();
                        return;
                    }
                    
                    console.log(`üì¶ Tentativo ${urlIndex + 1}:`, urls[urlIndex]);
                    
                    const script = document.createElement('script');
                    script.src = urls[urlIndex];
                    script.onload = function() {
                        console.log('‚úÖ GLTFLoader caricato da:', urls[urlIndex]);
                        if (typeof THREE.GLTFLoader !== 'undefined') {
                            loadGLTFFileInternal(file);
                        } else {
                            urlIndex++;
                            tryLoadGLTFLoader();
                        }
                    };
                    script.onerror = function() {
                        console.warn('‚ö†Ô∏è Fallito:', urls[urlIndex]);
                        urlIndex++;
                        tryLoadGLTFLoader();
                    };
                    document.head.appendChild(script);
                }
                
                tryLoadGLTFLoader();
                return;
            }
            
            loadGLTFFileInternal(file);
        }
        
        function loadGLTFFileInternal(file) {
            console.log('üîß Inizio caricamento interno GLTF/GLB:', file.name);
            updateStatus(`Parsing ${file.name}...`);
            
            // Pulisci il modello precedente
            if (currentModel) {
                console.log('üóëÔ∏è Rimozione modello precedente dalla scena');
                scene.remove(currentModel);
                currentModel = null;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    console.log('üìÑ File GLTF/GLB letto, inizio parsing...');
                    updateStatus('Parsing file GLTF/GLB...');
                    
                    const arrayBuffer = event.target.result;
                    const loader = new THREE.GLTFLoader();
                    
                    loader.parse(arrayBuffer, '', function(gltf) {
                        console.log('‚úÖ Modello GLTF/GLB parsato con successo');
                        updateStatus('Aggiunta modello alla scena...');
                        
                        const model = gltf.scene;
                        model.name = file.name;
                        
                        // Configura ombre per tutti i mesh
                        model.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Log materiali trovati
                                if (child.material) {
                                    console.log(`üé® Mesh: ${child.name}, Materiale: ${child.material.name || 'unnamed'}`);
                                }
                            }
                        });
                        
                        // Aggiungi il modello all'array e alla scena
                        loadedModels.push(model);
                        scene.add(model);
                        
                        console.log('üìä Modello GLTF/GLB aggiunto alla scena');
                        
                        // Reset e poi ripristina vista
                        resetViewInternal();
                        restoreView();
                        hideLoader();
                        updateStatus(`‚úÖ ${file.name} caricato! Totale modelli: ${loadedModels.length}`);
                        
                    }, function(error) {
                        console.error('‚ùå Errore parsing GLTF/GLB:', error);
                        showError('Errore nel parsing del file GLTF/GLB: ' + error.message);
                        hideLoader();
                    });
                    
                } catch (error) {
                    console.error('‚ùå Errore caricamento GLTF/GLB:', error);
                    showError('Errore nel caricamento del file GLTF/GLB: ' + error.message);
                    hideLoader();
                }
            };
            
            reader.onerror = function(error) {
                console.error('‚ùå Errore lettura file:', error);
                showError('Errore nella lettura del file GLTF/GLB');
                hideLoader();
            };
            
            reader.onprogress = function(event) {
                if (event.lengthComputable) {
                    const percent = Math.round((event.loaded / event.total) * 100);
                    updateStatus(`Lettura file: ${percent}%`);
                }
            };
            
            console.log('üìñ Inizio lettura file come ArrayBuffer...');
            reader.readAsArrayBuffer(file);
        }
        
        // ===== CARICAMENTO STL =====
        function loadSTLFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    const data = event.target.result;
                    let geometry;
                    
                    if (typeof data === 'string') {
                        geometry = parseSTLText(data);
                    } else {
                        geometry = parseSTLBinary(data);
                    }
                    
                    const material = new THREE.MeshLambertMaterial({ 
                        color: 0x888888,
                        side: THREE.DoubleSide
                    });
                    
                    const model = new THREE.Mesh(geometry, material);
                    model.castShadow = true;
                    model.receiveShadow = true;
                    model.name = file.name;
                    
                    // Aggiungi il modello all'array e alla scena
                    loadedModels.push(model);
                    scene.add(model);
                    
                    // Reset e poi ripristina vista
                    resetViewInternal();
                    restoreView();
                    hideLoader();
                    updateStatus(`‚úÖ ${file.name} caricato! Totale modelli: ${loadedModels.length}`);
                    
                } catch (error) {
                    console.error('Errore caricamento STL:', error);
                    showError('Errore nel caricamento del file STL: ' + error.message);
                    hideLoader();
                }
            };
            
            reader.onerror = function() {
                showError('Errore nella lettura del file');
                hideLoader();
            };
            
            // Prova prima come testo, poi come binario
            reader.readAsText(file);
        }
        
        // ===== PARSER STL =====
        function parseSTLText(text) {
            const vertices = [];
            const lines = text.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('vertex')) {
                    const coords = line.split(' ');
                    vertices.push(
                        parseFloat(coords[1]) || 0,
                        parseFloat(coords[2]) || 0,
                        parseFloat(coords[3]) || 0
                    );
                }
            }
            
            if (vertices.length === 0) {
                throw new Error('Nessun vertice trovato nel file STL');
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        function parseSTLBinary(data) {
            // Implementazione semplificata per STL binario
            const view = new DataView(data);
            const triangleCount = view.getUint32(80, true);
            const vertices = [];
            
            let offset = 84;
            
            for (let i = 0; i < triangleCount; i++) {
                // Skip normal vector (12 bytes)
                offset += 12;
                
                // Read 3 vertices (9 floats)
                for (let j = 0; j < 9; j++) {
                    vertices.push(view.getFloat32(offset, true));
                    offset += 4;
                }
                
                // Skip attribute byte count
                offset += 2;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        // ===== CONTROLLI MOUSE =====
        function onMouseDown(event) {
            isMouseDown = true;
            mouseButton = event.button;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            event.preventDefault();
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            
            if (mouseButton === 0) {
                // Tasto sinistro: Pan camera
                camera.position.x -= deltaX * 0.01;
                camera.position.y += deltaY * 0.01;
            } else if (mouseButton === 2 && loadedModels.length > 0) {
                // Tasto destro: Ruota tutti i modelli
                loadedModels.forEach(model => {
                    model.rotation.y += deltaX * 0.01;
                    model.rotation.x += deltaY * 0.01;
                });
            }
            
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            const delta = event.deltaY > 0 ? 0.1 : -0.1;
            camera.position.z += delta;
            camera.position.z = Math.max(0.5, Math.min(100, camera.position.z));
        }
        
        // ===== UTILITY =====
        function resetViewInternal() {
            // Reset interno senza messaggio di status
            camera.position.set(0, 0.3, 1);
            camera.rotation.set(0, 0, 0);
            loadedModels.forEach(model => {
                model.rotation.set(0, 0, 0);
            });
            if (loadedModels.length > 0) {
                autoFitAllModels();
            }
        }
        
        function resetView() {
            resetViewInternal();
            updateStatus('üîÑ Vista resettata');
        }
        
        function clearAll() {
            // Rimuovi tutti i modelli dalla scena
            loadedModels.forEach(model => {
                scene.remove(model);
                // Pulisci geometrie e materiali
                model.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => disposeMaterial(mat));
                            } else {
                                disposeMaterial(child.material);
                            }
                        }
                    }
                });
            });
            
            // Svuota l'array
            loadedModels = [];
            
            // Reset camera
            camera.position.set(0, 0, 5);
            camera.rotation.set(0, 0, 0);
            
            updateStatus('üóëÔ∏è Tutti i modelli rimossi');
        }
        
        // ===== SISTEMA ANIMAZIONE =====
        function onAnimationFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('üìΩÔ∏è Caricamento file animazione:', file.name);
            updateStatus(`Caricamento animazione ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    animationData = parseAnimationFile(content, file.name);
                    
                    if (animationData && animationData.length > 0) {
                        document.getElementById('animationBtn').disabled = false;
                        updateStatus(`‚úÖ Animazione caricata: ${animationData.length} keyframes`);
                        console.log('üé¨ Dati animazione:', animationData);
                    } else {
                        document.getElementById('animationBtn').disabled = true;
                        updateStatus('‚ùå File animazione vuoto o invalido');
                    }
                } catch (error) {
                    console.error('‚ùå Errore parsing animazione:', error);
                    showError('Errore nel file animazione: ' + error.message);
                    document.getElementById('animationBtn').disabled = true;
                }
            };
            
            reader.onerror = function() {
                showError('Errore nella lettura del file animazione');
                document.getElementById('animationBtn').disabled = true;
            };
            
            reader.readAsText(file);
        }
        
        function parseAnimationFile(content, fileName) {
            console.log('üìÑ Parsing file animazione:', fileName);
            
            const lines = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const keyframes = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Formato: tempo,modello,x,y,z
                // Esempio: 0,model1.obj,0,0,0
                // Esempio: 2000,model1.obj,5,0,0
                const parts = line.split(',').map(p => p.trim());
                
                if (parts.length >= 5) {
                    const time = parseFloat(parts[0]);
                    const modelName = parts[1];
                    const x = parseFloat(parts[2]);
                    const y = parseFloat(parts[3]);
                    const z = parseFloat(parts[4]);
                    
                    if (!isNaN(time) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        keyframes.push({
                            time: time,
                            modelName: modelName,
                            position: { x, y, z }
                        });
                        console.log(`‚è±Ô∏è Keyframe ${i+1}: t=${time}ms, modello="${modelName}", pos=(${x},${y},${z})`);
                    } else {
                        console.warn(`‚ö†Ô∏è Riga ${i+1} invalida:`, line);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Formato riga ${i+1} errato (servono 5 campi):`, line);
                }
            }
            
            // Ordina per tempo
            keyframes.sort((a, b) => a.time - b.time);
            
            console.log(`‚úÖ Parsed ${keyframes.length} keyframes validi`);
            return keyframes;
        }
        
        function startAnimation() {
            if (!animationData || animationData.length === 0) {
                showError('Nessuna animazione caricata');
                return;
            }
            
            if (loadedModels.length === 0) {
                showError('Nessun modello caricato per animare');
                return;
            }
            
            console.log('üé¨ Inizio animazione con', animationData.length, 'keyframes');
            
            animationInProgress = true;
            animationStartTime = performance.now();
            
            // Cambia pulsante
            const btn = document.getElementById('animationBtn');
            btn.textContent = '‚èπÔ∏è Stop Animazione';
            btn.onclick = stopAnimation;
            
            updateStatus('üé¨ Animazione in corso...');
        }
        
        function stopAnimation() {
            console.log('‚èπÔ∏è Stop animazione');
            
            animationInProgress = false;
            animationStartTime = 0;
            
            // Ripristina pulsante
            const btn = document.getElementById('animationBtn');
            btn.textContent = '‚ñ∂Ô∏è Avvia Animazione';
            btn.onclick = startAnimation;
            
            updateStatus('‚èπÔ∏è Animazione fermata');
        }
        
        function updateAnimation() {
            const currentTime = performance.now() - animationStartTime;
            
            // Trova i keyframes per ogni modello
            const modelKeyframes = {};
            animationData.forEach(kf => {
                if (!modelKeyframes[kf.modelName]) {
                    modelKeyframes[kf.modelName] = [];
                }
                modelKeyframes[kf.modelName].push(kf);
            });
            
            // Anima ogni modello
            loadedModels.forEach(model => {
                const modelName = model.name;
                const keyframes = modelKeyframes[modelName];
                
                if (!keyframes || keyframes.length === 0) return;
                
                // Trova i keyframes precedente e successivo
                let prevKf = null;
                let nextKf = null;
                
                for (let i = 0; i < keyframes.length; i++) {
                    if (keyframes[i].time <= currentTime) {
                        prevKf = keyframes[i];
                    }
                    if (keyframes[i].time > currentTime && !nextKf) {
                        nextKf = keyframes[i];
                        break;
                    }
                }
                
                if (prevKf && nextKf) {
                    // Interpola tra i due keyframes
                    const duration = nextKf.time - prevKf.time;
                    const elapsed = currentTime - prevKf.time;
                    const t = Math.min(elapsed / duration, 1.0); // 0-1
                    
                    // Interpolazione lineare
                    model.position.x = lerp(prevKf.position.x, nextKf.position.x, t);
                    model.position.y = lerp(prevKf.position.y, nextKf.position.y, t);
                    model.position.z = lerp(prevKf.position.z, nextKf.position.z, t);
                    
                } else if (prevKf && !nextKf) {
                    // Ultimo keyframe raggiunto
                    model.position.x = prevKf.position.x;
                    model.position.y = prevKf.position.y;
                    model.position.z = prevKf.position.z;
                } else if (!prevKf && nextKf) {
                    // Prima dell'inizio
                    model.position.x = nextKf.position.x;
                    model.position.y = nextKf.position.y;
                    model.position.z = nextKf.position.z;
                }
            });
            
            // Controlla se animazione finita
            const maxTime = Math.max(...animationData.map(kf => kf.time));
            if (currentTime >= maxTime + 1000) { // +1s di buffer
                stopAnimation();
                updateStatus('‚úÖ Animazione completata');
            }
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        // ===== SISTEMA SCENARI =====
        function onScenarioFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('üéØ Caricamento file scenari:', file.name);
            updateStatus(`Caricamento scenari ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    scenariosConfig = parseScenariosFile(content, file.name);
                    
                    if (scenariosConfig && scenariosConfig.length > 0) {
                        populateScenarioSelect();
                        updateStatus(`‚úÖ ${scenariosConfig.length} scenari caricati`);
                        console.log('üéØ Scenari:', scenariosConfig);
                    } else {
                        updateStatus('‚ùå File scenari vuoto o invalido');
                    }
                } catch (error) {
                    console.error('‚ùå Errore parsing scenari:', error);
                    showError('Errore nel file scenari: ' + error.message);
                }
            };
            
            reader.onerror = function() {
                showError('Errore nella lettura del file scenari');
            };
            
            reader.readAsText(file);
        }
        
        function parseScenariosFile(content, fileName) {
            console.log('üìÑ Parsing file scenari:', fileName);
            
            const lines = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const scenarios = [];
            let currentScenario = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.startsWith('[') && line.endsWith(']')) {
                    // Nuovo scenario
                    if (currentScenario) {
                        scenarios.push(currentScenario);
                    }
                    
                    const scenarioName = line.slice(1, -1);
                    currentScenario = {
                        name: scenarioName,
                        models: [],
                        animations: []
                    };
                    console.log('üéØ Nuovo scenario:', scenarioName);
                    
                } else if (currentScenario) {
                    if (line.startsWith('model=')) {
                        // File modello
                        const modelPath = line.substring(6);
                        currentScenario.models.push(modelPath);
                        console.log(`  üì¶ Modello: ${modelPath}`);
                        
                    } else if (line.startsWith('animation=')) {
                        // File animazione
                        const animationPath = line.substring(10);
                        currentScenario.animations.push(animationPath);
                        console.log(`  üé¨ Animazione: ${animationPath}`);
                    }
                }
            }
            
            // Aggiungi ultimo scenario
            if (currentScenario) {
                scenarios.push(currentScenario);
            }
            
            console.log(`‚úÖ Parsed ${scenarios.length} scenari`);
            return scenarios;
        }
        
        function populateScenarioSelect() {
            const select = document.getElementById('scenarioSelect');
            
            // Pulisci opzioni esistenti
            select.innerHTML = '<option value="">Seleziona Scenario...</option>';
            
            // Aggiungi scenari
            scenariosConfig.forEach((scenario, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = scenario.name;
                select.appendChild(option);
            });
            
            select.disabled = false;
        }
        
        function loadScenario() {
            const select = document.getElementById('scenarioSelect');
            const selectedIndex = parseInt(select.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= scenariosConfig.length) {
                document.getElementById('scenarioBtn').disabled = true;
                return;
            }
            
            currentScenario = scenariosConfig[selectedIndex];
            console.log('üéØ Scenario selezionato:', currentScenario.name);
            
            updateStatus(`Caricamento scenario: ${currentScenario.name}`);
            
            // Pulisci scena esistente
            clearAll();
            
            // Carica modelli del scenario
            loadScenarioModels(currentScenario.models, function() {
                // Carica animazioni del scenario
                loadScenarioAnimations(currentScenario.animations, function() {
                    document.getElementById('scenarioBtn').disabled = false;
                    updateStatus(`‚úÖ Scenario "${currentScenario.name}" pronto (${currentScenario.models.length} modelli, ${currentScenario.animations.length} animazioni)`);
                });
            });
        }
        
        function loadScenarioModels(modelPaths, callback) {
            if (modelPaths.length === 0) {
                callback();
                return;
            }
            
            let loadedCount = 0;
            const totalCount = modelPaths.length;
            
            console.log(`üì¶ Caricamento ${totalCount} modelli per scenario...`);
            
            modelPaths.forEach(modelPath => {
                // Simula caricamento file dal percorso
                console.warn(`‚ö†Ô∏è Caricamento automatico file non implementato: ${modelPath}`);
                console.log(`üí° Manualmente carica il file: ${modelPath}`);
                
                loadedCount++;
                if (loadedCount >= totalCount) {
                    callback();
                }
            });
        }
        
        function loadScenarioAnimations(animationPaths, callback) {
            if (animationPaths.length === 0) {
                scenarioAnimations = [];
                callback();
                return;
            }
            
            let loadedCount = 0;
            const totalCount = animationPaths.length;
            scenarioAnimations = [];
            
            console.log(`üé¨ Caricamento ${totalCount} animazioni per scenario...`);
            
            animationPaths.forEach(animationPath => {
                // Simula caricamento animazione dal percorso
                console.warn(`‚ö†Ô∏è Caricamento automatico animazioni non implementato: ${animationPath}`);
                console.log(`üí° Manualmente carica l'animazione: ${animationPath}`);
                
                // Per ora aggiungi placeholder
                scenarioAnimations.push({
                    name: animationPath,
                    data: [] // Vuoto per ora
                });
                
                loadedCount++;
                if (loadedCount >= totalCount) {
                    callback();
                }
            });
        }
        
        function executeScenario() {
            if (!currentScenario || scenarioAnimations.length === 0) {
                showError('Nessuno scenario o animazioni caricate');
                return;
            }
            
            if (loadedModels.length === 0) {
                showError('Nessun modello caricato per lo scenario');
                return;
            }
            
            console.log('üé¨ Esecuzione scenario:', currentScenario.name);
            
            scenarioInProgress = true;
            currentAnimationIndex = 0;
            
            // Cambia pulsante
            const btn = document.getElementById('scenarioBtn');
            btn.textContent = '‚èπÔ∏è Stop Scenario';
            btn.onclick = stopScenario;
            
            updateStatus(`üé¨ Esecuzione scenario: ${currentScenario.name}`);
            
            // Avvia prima animazione
            executeNextAnimation();
        }
        
        function executeNextAnimation() {
            if (!scenarioInProgress || currentAnimationIndex >= scenarioAnimations.length) {
                // Scenario completato
                stopScenario();
                updateStatus('‚úÖ Scenario completato');
                return;
            }
            
            const animation = scenarioAnimations[currentAnimationIndex];
            console.log(`üé¨ Esecuzione animazione ${currentAnimationIndex + 1}/${scenarioAnimations.length}: ${animation.name}`);
            
            updateStatus(`üé¨ Animazione ${currentAnimationIndex + 1}/${scenarioAnimations.length}: ${animation.name}`);
            
            // Per ora simula animazione di 3 secondi
            setTimeout(() => {
                if (scenarioInProgress) {
                    currentAnimationIndex++;
                    executeNextAnimation();
                }
            }, 3000);
        }
        
        function stopScenario() {
            console.log('‚èπÔ∏è Stop scenario');
            
            scenarioInProgress = false;
            currentAnimationIndex = 0;
            
            // Ferma anche animazione singola se in corso
            if (animationInProgress) {
                stopAnimation();
            }
            
            // Ripristina pulsante
            const btn = document.getElementById('scenarioBtn');
            btn.textContent = 'üé¨ Esegui Scenario';
            btn.onclick = executeScenario;
            
            updateStatus('‚èπÔ∏è Scenario fermato');
        }
        
        // ===== SISTEMA NAVIGAZIONE E HOME PAGE =====
        function onHomeConfigSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('üè† Caricamento configurazione Home:', file.name);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    homeConfig = parseHomeConfig(content, file.name);
                    
                    if (homeConfig && homeConfig.scenarios && homeConfig.scenarios.length > 0) {
                        populateHomePage();
                        console.log('üè† Home configurata:', homeConfig);
                    } else {
                        showError('File configurazione Home vuoto o invalido');
                    }
                } catch (error) {
                    console.error('‚ùå Errore parsing Home config:', error);
                    showError('Errore nel file configurazione Home: ' + error.message);
                }
            };
            
            reader.onerror = function() {
                showError('Errore nella lettura del file configurazione Home');
            };
            
            reader.readAsText(file);
        }
        
        function parseHomeConfig(content, fileName) {
            console.log('üìÑ Parsing configurazione Home:', fileName);
            
            const lines = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const config = {
                title: "üéØ Visualizzatore Modelli 3D",
                subtitle: "Seleziona uno scenario per iniziare",
                scenarios: []
            };
            
            let currentScenario = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.startsWith('title=')) {
                    config.title = line.substring(6);
                    console.log('üè† Titolo:', config.title);
                    
                } else if (line.startsWith('subtitle=')) {
                    config.subtitle = line.substring(9);
                    console.log('üè† Sottotitolo:', config.subtitle);
                    
                } else if (line.startsWith('[') && line.endsWith(']')) {
                    // Nuovo scenario
                    if (currentScenario) {
                        config.scenarios.push(currentScenario);
                    }
                    
                    const scenarioName = line.slice(1, -1);
                    currentScenario = {
                        name: scenarioName,
                        description: '',
                        image: '',
                        models: [],
                        animations: []
                    };
                    console.log('üéØ Scenario:', scenarioName);
                    
                } else if (currentScenario) {
                    if (line.startsWith('description=')) {
                        currentScenario.description = line.substring(12);
                        console.log(`  üìù Descrizione: ${currentScenario.description}`);
                        
                    } else if (line.startsWith('image=')) {
                        currentScenario.image = line.substring(6);
                        console.log(`  üñºÔ∏è Immagine: ${currentScenario.image}`);
                        
                    } else if (line.startsWith('model=')) {
                        currentScenario.models.push(line.substring(6));
                        console.log(`  üì¶ Modello: ${line.substring(6)}`);
                        
                    } else if (line.startsWith('animation=')) {
                        currentScenario.animations.push(line.substring(10));
                        console.log(`  üé¨ Animazione: ${line.substring(10)}`);
                    }
                }
            }
            
            // Aggiungi ultimo scenario
            if (currentScenario) {
                config.scenarios.push(currentScenario);
            }
            
            console.log(`‚úÖ Configurazione Home parsata: ${config.scenarios.length} scenari`);
            return config;
        }
        
        function populateHomePage() {
            // Aggiorna titolo con logo e sottotitolo
            const header = document.getElementById('homeHeader');
            header.querySelector('h1').innerHTML = `<img src="newlogo.png" alt="Logo" class="logo">${homeConfig.title}`;
            header.querySelector('p').textContent = homeConfig.subtitle;
            
            // Popola lista scenari
            const scenariosList = document.getElementById('scenariosList');
            scenariosList.innerHTML = '';
            
            homeConfig.scenarios.forEach((scenario, index) => {
                const card = document.createElement('div');
                card.className = 'scenario-card';
                card.onclick = () => openScenario(index);
                
                card.innerHTML = `
                    <div class="scenario-image">
                        ${scenario.image ? 
                            `<img src="${scenario.image}" alt="${scenario.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                             <div class="placeholder-image" style="display:none;">üéØ</div>` :
                            `<div class="placeholder-image">üéØ</div>`
                        }
                    </div>
                    <div class="scenario-info">
                        <h3>${scenario.name}</h3>
                        <p>${scenario.description}</p>
                    </div>
                `;
                
                scenariosList.appendChild(card);
            });
            
            console.log('‚úÖ Home Page popolata con', homeConfig.scenarios.length, 'scenari');
        }
        
        function openScenario(scenarioIndex) {
            if (!homeConfig || !homeConfig.scenarios[scenarioIndex]) {
                showError('Scenario non trovato');
                return;
            }
            
            const scenario = homeConfig.scenarios[scenarioIndex];
            console.log('üéØ Apertura scenario:', scenario.name);
            
            // Salva scenario corrente
            currentScenario = scenario;
            scenariosConfig = homeConfig.scenarios;
            
            // Cambia pagina
            currentPage = 'scenario';
            document.getElementById('homePage').classList.add('hidden');
            document.getElementById('scenarioPage').classList.remove('hidden');
            
            // Aggiorna titolo scenario
            document.getElementById('scenarioTitle').textContent = scenario.name;
            
            // Pulisci scena e prepara scenario
            clearAll();
            
            // Abilita pulsante esecuzione scenario se ha animazioni
            const scenarioBtn = document.getElementById('scenarioBtn');
            if (scenario.animations && scenario.animations.length > 0) {
                scenarioBtn.disabled = false;
                scenarioBtn.textContent = 'üé¨ Esegui Scenario';
            } else {
                scenarioBtn.disabled = true;
                scenarioBtn.textContent = 'üé¨ Nessuna Animazione';
            }
            
            // Aggiorna status
            document.getElementById('status').textContent = `Scenario "${scenario.name}" caricato`;
            
            console.log('‚úÖ Scenario aperto:', scenario.name);
        }
        
        function goHome() {
            console.log('üè† Ritorno alla Home');
            
            // Ferma animazioni in corso
            if (animationInProgress) {
                stopAnimation();
            }
            if (scenarioInProgress) {
                stopScenario();
            }
            
            // Pulisci scena
            clearAll();
            
            // Cambia pagina
            currentPage = 'home';
            document.getElementById('scenarioPage').classList.add('hidden');
            document.getElementById('homePage').classList.remove('hidden');
            
            // Reset variabili scenario
            currentScenario = null;
            scenarioAnimations = [];
            
            console.log('‚úÖ Home Page mostrata');
        }
        
        function loadDefaultHomeConfig() {
            console.log('üè† Caricamento automatico home_config.txt...');
            
            fetch('home_config.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(content => {
                    try {
                        homeConfig = parseHomeConfig(content, 'home_config.txt');
                        
                        if (homeConfig && homeConfig.scenarios && homeConfig.scenarios.length > 0) {
                            populateHomePage();
                            console.log('üè† Home configurata automaticamente:', homeConfig);
                            updateStatus(`‚úÖ ${homeConfig.scenarios.length} scenari caricati automaticamente`);
                        } else {
                            console.warn('‚ö†Ô∏è File home_config.txt vuoto o invalido');
                            updateStatus('‚ö†Ô∏è File configurazione Home vuoto');
                        }
                    } catch (error) {
                        console.error('‚ùå Errore parsing home_config.txt:', error);
                        updateStatus('‚ùå Errore parsing configurazione Home');
                    }
                })
                .catch(error => {
                    console.warn('‚ö†Ô∏è Impossibile caricare home_config.txt automaticamente:', error.message);
                    updateStatus('‚ö†Ô∏è File home_config.txt non trovato - usa "Carica Configurazione Home"');
                });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('Status:', message);
        }
        
        function showLoader() {
            document.getElementById('loader').classList.remove('hidden');
        }
        
        function hideLoader() {
            document.getElementById('loader').classList.add('hidden');
        }
        
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('error').classList.remove('hidden');
        }
        
        function hideError() {
            document.getElementById('error').classList.add('hidden');
        }
        
        // ===== AVVIO =====
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Avvio visualizzatore finale...');
            setTimeout(init, 100);
        });
        
        console.log('üìÑ Visualizzatore finale caricato');
    </script>
</body>
</html>